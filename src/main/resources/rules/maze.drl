package com.boruta

import com.boruta.backwardchaining.agent.structure.Agent
import com.boruta.backwardchaining.maze.structure.Maze
import com.boruta.backwardchaining.agent.structure.Energy
import java.util.List
import com.boruta.backwardchaining.enemy.command.KillEnemyCommand
import java.util.Random
import com.boruta.backwardchaining.navigation.helper.OppositeDirectionHelper
import com.boruta.backwardchaining.navigation.structure.Position
import com.boruta.backwardchaining.navigation.structure.Location
import com.boruta.backwardchaining.navigation.helper.KnownPositionsHelper
import com.boruta.backwardchaining.maze.helper.NeighborsHelper
import com.boruta.backwardchaining.maze.structure.Path
import java.util.ArrayList
import java.util.Collections
import com.boruta.backwardchaining.agent.command.ChooseTargetCommand

// choose next agent target
rule "select enemy target" salience 10
    when
        $maze : Maze();
        $agent : Agent(!isTarget(), !isFinished());
    then
        ChooseTargetCommand chooseTargetCommand = new ChooseTargetCommand($maze, $agent);
        if(!chooseTargetCommand.execute()) {
            $agent.setFinished(true);
        }
        update($agent);
end

// zbudowanie możliwych ścieżek od aktualnej pozycji do celu
rule "build pathes" salience 5
    when
        $agent : Agent(isTarget(), !isFinished());
        $maze : Maze();
    then
        List<Position> usedPosition = new ArrayList<>();
        List<Position> workingPosition = new ArrayList<>();
        workingPosition.add($agent.getTarget());
        usedPosition.add($agent.getTarget());

        while(workingPosition.size() > 0) {
            for (Position neighborPosition : NeighborsHelper.getNeighbors(workingPosition.get(0), $maze)) {
                if($agent.getKnownPositions().contains(neighborPosition) && !usedPosition.contains(neighborPosition)) {
                    usedPosition.add(neighborPosition.clone());
                    workingPosition.add(neighborPosition.clone());
                    insert(new Path(workingPosition.get(0), neighborPosition.clone()));
                }
            }
            workingPosition.remove(0);
        }
end

rule "all in one" salience 5
    when
        $agent : Agent(isTarget(), !isFinished(), $position : getCurrentPosition(), $target : getTarget(), $energy : getEnergy(), $energy.currentLevel() > 0)
        $maze : Maze()
        getPath($target, $position, nextMove;)
        $pathes : ArrayList(size > 0) from collect (Path())
    then
        int direction;

        direction = $position.getDirection(nextMove.getPosition());

                    for (int i = 0; i < $pathes.size(); i++) {

                       Path f = (Path)$pathes.get(i);

                       retract(f);

                    }

        if($agent.getWayback().size() >= $agent.getEnergy().currentLevel()) {
            direction = $agent.getWayback().get($agent.getWayback().size() - 1);
        }

        $agent.go(direction);
        for (Position position : KnownPositionsHelper.getVisiblePositions($agent.getCurrentPosition(), $maze)) {
            if(!$agent.getKnownPositions().contains(position)) {
                $agent.getKnownPositions().add(position);
            }
        }

        KillEnemyCommand killEnemyCommand = new KillEnemyCommand($maze, $agent);
        killEnemyCommand.execute($agent.getCurrentPosition());


          if($agent.getCurrentPosition().equals($target)) {
              $agent.removeTarget();
              update($agent);
          }

                update($agent);
                update($maze);
end

query isPath(Position x, Position y)
    Path(x, y;)
    or
    (Path(z, y;) and isPath(x, z;))
end

query getPath(Position x, Position y, Path k)
    k := Path(x, y;)
    or
    (k := Path(z, y;) and isPath(x, z;))
end