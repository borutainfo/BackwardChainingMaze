package com.boruta

import com.boruta.backwardchaining.agent.structure.Agent
import com.boruta.backwardchaining.maze.structure.Maze
import com.boruta.backwardchaining.agent.structure.Energy
import java.util.List
import com.boruta.backwardchaining.enemy.command.KillEnemyCommand
import java.util.Random
import com.boruta.backwardchaining.navigation.helper.OppositeDirectionHelper
import com.boruta.backwardchaining.navigation.structure.Position
import com.boruta.backwardchaining.navigation.helper.KnownPositionsHelper
import com.boruta.backwardchaining.maze.helper.NeighborsHelper
import com.boruta.backwardchaining.maze.structure.Path
import java.util.ArrayList
import java.util.Collections
import com.boruta.backwardchaining.agent.command.ChooseTargetCommand
import com.boruta.backwardchaining.navigation.helper.PathsFromTargetHelper

// choose next agent target
rule "select enemy target" salience 4
    when
        $maze : Maze();
        $agent : Agent(!isFinished(), !isTargetChoosed());
    then
        ChooseTargetCommand chooseTargetCommand = new ChooseTargetCommand($maze, $agent);
        if(!chooseTargetCommand.execute()) {
            $agent.setFinished(true);
        }
        update($agent);
end

// build pathes from target to current position
rule "build pathes" salience 3
    when
        $maze : Maze();
        $agent : Agent(!isFinished(), isTargetChoosed());
    then
        List<Path> result = PathsFromTargetHelper.getPaths($maze, $agent);

        for(Path path : result) {
            insert(path);
        }
end

rule "move" salience 2
    when
        $agent : Agent(!isFinished(), isTargetChoosed(), $target : getTarget(), $position : getCurrentPosition(), $energy : getEnergy(), $energy.currentLevel() > 0)
        $maze : Maze()
        getPath($target, $position, nextMove;)
        $pathes : ArrayList(size > 0) from collect (Path())
    then
        int direction;

        direction = $position.getDirection(nextMove.getPathTo());

                    for (int i = 0; i < $pathes.size(); i++) {

                       Path f = (Path)$pathes.get(i);

                       retract(f);

                    }

        if($agent.getWayback().size() >= $agent.getEnergy().currentLevel()) {
            direction = $agent.getWayback().get($agent.getWayback().size() - 1);
        }

        $agent.go(direction);
        for (Position position : KnownPositionsHelper.getVisiblePositions($agent.getCurrentPosition(), $maze)) {
            if(!$agent.getKnownPositions().contains(position)) {
                $agent.getKnownPositions().add(position);
            }
        }

        KillEnemyCommand killEnemyCommand = new KillEnemyCommand($maze, $agent);
        killEnemyCommand.execute($agent.getCurrentPosition());


          if($agent.getCurrentPosition().equals($target)) {
              $agent.removeTarget();
              update($agent);
          }

                update($agent);
                update($maze);
end


query isPath(Position x, Position y)
    Path(x, y;)
    or
    (Path(z, y;) and isPath(x, z;))
end

query getPath(Position x, Position y, Path k)
    k := Path(x, y;)
    or
    (k := Path(z, y;) and isPath(x, z;))
end